;; SPDX-FileCopyrightText: 2019 Serokell <https://serokell.io>
;;
;; SPDX-License-Identifier: MPL-2.0

;; Local state serialization/parsing
;; First 4 bits of cell is constructorId

builder store_StateTag(builder b, int tag) {
  return b.store_uint(4, tag);
}

(slice, int) load_StateTag(slice s) {
  return s.load_uint(4);
}

;; MkStateWaitingBoth

int StateTags::WaitingBoth() { return 1; }

cell mkStateWaitingBoth() {
  return begin_cell()
    .store_StateTag(StateTags::WaitingBoth())
    .end_cell();
}

(slice, ()) load_StateWaitingBoth(slice s) { return (s, ()); }

;; MkStateWaitingOne

int StateTags::WaitingOne() { return 2; }

cell mkStateWaitingOne(slice addr, cell pk_cell) {
  cell addr_cell =
    begin_cell()
      .store_slice(addr)
      .end_cell();

  return begin_cell()
    .store_StateTag(StateTags::WaitingOne())
    .store_ref(addr_cell)
    .store_ref(pk_cell)
    .end_cell();
}

;; addr, pk
(cell, cell) parseStateWaitingOne(slice s) {
  throw_if(33, s~load_StateTag() != StateTags::WaitingOne());
  var addr = s~load_ref();
  var pk = s~load_ref();
  return (addr, pk);
}

;; MkStateOpen

int StateTags::Open() { return 3; }

cell mkStateOpen(cell addr1, cell addr2) {
  return begin_cell()
    .store_StateTag(StateTags::Open())
    .store_ref(addr1)
    .store_ref(addr2)
    .end_cell();
}
